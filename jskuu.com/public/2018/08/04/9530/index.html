<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="WEB前端开发 - 专注前端开发        -专注前端开发，关注用户体验">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">

    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>React Fiber初探 | WEB前端开发 - 专注前端开发        -专注前端开发，关注用户体验</title>


    <link rel="alternate" href="/atom.xml" title="WEB前端开发 - 专注前端开发        -专注前端开发，关注用户体验" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1274315707 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1274315707%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <wb:follow-button uid="5435940750" type="red_2" width="136" height="24" ></wb:follow-button>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">WEB前端开发 - 专注前端开发        -专注前端开发，关注用户体验</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="javascript:;"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="javascript:;"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="javascript:;"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="React Fiber初探">
            
	            React Fiber初探
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/ ">
             
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/08/04</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>非原创 转自 <a href="http://blog.codingplayboy.com/" target="_blank" rel="noopener">http://blog.codingplayboy.com/</a></p>
<p>React 16版本已经推出多时，提出了包括Portal，异常边界等新特性，最重要的是重写了调和算法，推出了新版本算法实现-Fiber，于是博主历时三周，在业余时间学习Fiber架构实现和源码，对Fiber整体有了初步了解，并总结分享出来，若对一些源码不感兴趣，大可跳过，另博主水平有限，若有不对之处，欢迎指正。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>React的定位是一个构建用户界面的JavaScript类库，它使用JavaScript语言开发UI组件，可以使用多种方式渲染这些组件，输出用户界面，较大程度的达到了跨技术栈跨平台的兼容重用：</p>
<blockquote>
<p>We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code.</p>
</blockquote>
<h2 id="全新的内部架构"><a href="#全新的内部架构" class="headerlink" title="全新的内部架构"></a>全新的内部架构</h2><ul>
<li>React 16 采用了称为“Fiber”的全新的内部架构。官方对 Fiber 的一句话解释是“React Fiber是对核心算法的一次重新实现”。</li>
<li>以前的 React 使用的称为“Stack”的更新方式下，一个调用链很长并且计算量很大的任务的调用栈会如下图：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/27/07e1a030e2178d6f9bb672e3e746b7be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1"></p>
<ul>
<li>通过“Fiber”，React 使得大量的计算可以被拆解分片，异步化。每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做。从而保证了渲染的帧率，提高应用响应性。下图中每一个波谷代表深入某个分片的执行过程，每个波峰就是一个分片执行结束交还控制权的时机：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/27/26982bc2a1f18d5729350a96809783b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="2"></p>
<ul>
<li>在今年早些的 React Conf 上，React 开发者介绍了 Fiber 的<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">工作原理和实际效果</a>。在演示 Demo 中，一个非常深的组件树在使用 Fiber 前后的渲染帧率有了非常大的提升（视频 3:30 左右）。</li>
</ul>
<p>现在的React已然在以下几个方面发挥的都很不错：</p>
<ul>
<li>React Web应用用户界面开发；</li>
<li>React Native App用户界面开发；</li>
<li>Node.js服务端渲染；</li>
</ul>
<p>在这些不同场景，渲染的主体很明显是不一样的，有诸如web应用的DOM渲染，React Native的原生View渲染，服务端字符串渲染等，要做到兼容适应多种不同渲染环境，很显然，React不能局限固定渲染UI的方式。</p>
<p>React核心内容也确实只包括定义组件相关的内容和API，<a href="https://github.com/facebook/react/tree/master/packages/react" target="_blank" rel="noopener">源码可以查看</a>，实际项目中，可以看到首先需要使用如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure>
<p>这句代码做的就是引入了React核心源码模块。</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>上一节已经说到React核心内容只涉及如何定义组件，并不涉及具体的组件渲染（即输出用户界面），这需要额外引入渲染模块，以渲染React定义的组件：</p>
<p>  1.React DOM渲染模块：将React组件渲染为DOM，然后可以被浏览器处理呈现给用户，这就是通常在web应用中引入的react-dom模块：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./apps/App.js'</span>;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line"> &lt;App /&gt;,</span><br><span class="line"> <span class="built_in">document</span>.getElementById(<span class="string">'mainBox'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>2.React Native 渲染：将React组件渲染为移动端原生View，在React Native应用中引入react-native模块，它提供相应渲染方法可以渲染React组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AppRegistry &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./src/app.js'</span>;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'fuc'</span>, () =&gt; App);</span><br></pre></td></tr></table></figure>
<p>如上，App是React根组件，使用react-native渲染器的AppRegistry.registerComponent方法将其渲染为原生View。</p>
<p>3.React测试渲染：将React组件渲染为JSON树，用来完成<a href="https://facebook.github.io/jest" target="_blank" rel="noopener">Jest</a>的<a href="https://jestjs.io/blog/2016/07/27/jest-14.html" target="_blank" rel="noopener">快照测试</a>，内容在react-test-renderer模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactTestRenderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = ReactTestRenderer.create(</span><br><span class="line"> &lt;Link page=<span class="string">"https://www.facebook.com/"</span>&gt;Facebook&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log(renderer.toJSON());</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ &#123; type: 'a',</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/   props: &#123; href: 'https:/</span><span class="regexp">/www.facebook.com/</span><span class="string">' &#125;,</span></span><br><span class="line"><span class="string">//   children: [ '</span>Facebook<span class="string">' ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>4.React矢量图渲染：将React组件渲染为对应的适量图（ART库）；</p>
<p><code>web React应用是最常见的，也是最易于理解的，所以本篇后文均从React-DOM渲染器角度解析Fiber。</code></p>
<h3 id="调和（Reconciliation）"><a href="#调和（Reconciliation）" class="headerlink" title="调和（Reconciliation）"></a>调和（Reconciliation）</h3><p>如前面两节所述，React核心是定义组件，渲染组件方式由环境决定，定义组件，组件状态管理，生命周期方法管理，组件更新等应该跨平台一致处理，不受渲染环境影响，这部分内容统一由<a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener">调和器（Reconciler）</a>处理，<a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener">源码传送</a>，不同渲染器都会使用该模块。调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件。</p>
<h3 id="Stack-Reconciler"><a href="#Stack-Reconciler" class="headerlink" title="Stack Reconciler"></a>Stack Reconciler</h3><p>我们知道浏览器渲染引擎是单线程的，在React 15.x版本及之前版本，计算组件树变更时将会阻塞整个线程，整个渲染过程是连续不中断完成的，而这时的其他任务都会被阻塞，如动画等，这可能会使用户感觉到明显卡顿，比如当你在访问某一网站时，输入某个搜索关键字，更优先的应该是交互反馈或动画效果，如果交互反馈延迟200ms，用户则会感觉较明显的卡顿，而数据响应晚200毫秒并没太大问题。这个版本的调和器可以称为栈调和器（Stack Reconciler），其调和算法大致过程见<a href="http://blog.codingplayboy.com/2016/10/27/react_diff/" target="_blank" rel="noopener">React Diff</a>算法 和<a href="https://reactjs.org/docs/implementation-notes.html" target="_blank" rel="noopener">React Stack Reconciler</a>实现。</p>
<p>Stack Reconcilier的主要缺陷就是不能暂停渲染任务，也不能切分任务，无法有效平衡组件更新渲染与动画相关任务间的执行顺序，即不能划分任务优先级，有可能导致重要任务卡顿，动画掉帧等问题。</p>
<h2 id="Fiber-Reconciler"><a href="#Fiber-Reconciler" class="headerlink" title="Fiber Reconciler"></a>Fiber Reconciler</h2><p>React 16版本提出了一个更先进的调和器，它允许渲染进程分段完成，而不必须一次性完成，中间可以返回至主进程控制执行其他任务。而这是通过计算部分组件树的变更，并暂停渲染更新，询问主进程是否有更高需求的绘制或者更新任务需要执行，这些高需求的任务完成后才开始渲染。这一切的实现是在代码层引入了一个新的数据结构-Fiber对象，每一个组件实例对应有一个fiber实例，此fiber实例负责管理组件实例的更新，渲染任务及与其他fiber实例的联系。</p>
<p>这个新推出的调和器就叫做纤维调和器（Fiber Reconciler），它提供的新功能主要有：</p>
<ul>
<li>可切分，可中断任务；</li>
<li>可重用各分阶段任务，且可以设置优先级；</li>
<li>可以在父子组件任务间前进后退切换任务；</li>
<li>render方法可以返回多元素（即可以返回数组）；</li>
<li>支持异常边界处理异常；</li>
</ul>
<p>说了这么多，终于要正式出场本篇主角：Fiber了，React最新版本已经升到16.1.1，估计16.x稳定版不会太远，让我们先睹为快吧。</p>
<h2 id="Fiber与JavaScript"><a href="#Fiber与JavaScript" class="headerlink" title="Fiber与JavaScript"></a>Fiber与JavaScript</h2><p>前面说到Fiber可以异步实现不同优先级任务的协调执行，那么对于DOM渲染器而言，在JavaScript层是否提供这种方式呢，还是说只能使用setTimeout模拟呢？目前新版本主流浏览器已经提供了可用API：<br><code>requestIdleCallback和requestAnimationFrame:</code></p>
<p><a href="https://www.w3.org/TR/requestidlecallback/" target="_blank" rel="noopener">requestIdleCallback</a>: 在线程空闲时期调度执行低优先级函数；<br><a href="https://www.w3.org/TR/animation-timing/" target="_blank" rel="noopener">requestAnimationFrame</a>: 在下一个动画帧调度执行高优先级函数；</p>
<h2 id="空闲期（Idle-Period）"><a href="#空闲期（Idle-Period）" class="headerlink" title="空闲期（Idle Period）"></a>空闲期（Idle Period）</h2><p>通常，客户端线程执行任务时会以帧的形式划分，大部分设备控制在30-60帧是不会影响用户体验；在两个执行帧之间，主线程通常会有一小段空闲时间，<code>requestIdleCallback</code>可以在这个空闲期（Idle Period）调用空闲期回调（Idle Callback），执行一些任务。</p>
<p><img src="http://blog.codingplayboy.com/wp-content/uploads/2017/12/request-idle-callback.png" alt="adf"></p>
<h2 id="Fiber与requestIdleCallback"><a href="#Fiber与requestIdleCallback" class="headerlink" title="Fiber与requestIdleCallback"></a>Fiber与requestIdleCallback</h2><p>Fiber所做的就是需要分解渲染任务，然后根据优先级使用API调度，异步执行指定任务：</p>
<ul>
<li>低优先级任务由requestIdleCallback处理；</li>
<li>高优先级任务，如动画相关的由requestAnimationFrame处理；</li>
<li>requestIdleCallback可以在多个空闲期调用空闲期回调，执行任务；</li>
<li>requestIdleCallback方法提供deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；</li>
</ul>
<p>具体<a href="https://github.com/facebook/react/blob/master/packages/shared/ReactDOMFrameScheduling.js" target="_blank" rel="noopener">执行任务实现源码传送</a>：</p>
<p>1.若支持原生API，具体原生实现见上文给出的链接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rIC = <span class="built_in">window</span>.requestIdleCallback;</span><br><span class="line">cIC = <span class="built_in">window</span>.cancelIdleCallback;</span><br><span class="line"><span class="keyword">export</span> &#123;now, rIC, cIC&#125;;</span><br></pre></td></tr></table></figure>
<p>2.若不支持，则自定义实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isIdleScheduled = <span class="literal">false</span>; <span class="comment">// 是否在执行空闲期回调</span></span><br><span class="line"><span class="keyword">let</span> frameDeadlineObject = &#123;</span><br><span class="line"> didTimeout: <span class="literal">false</span>,</span><br><span class="line"> timeRemaining() &#123;</span><br><span class="line">   <span class="comment">// now = Performance.now || Date.now</span></span><br><span class="line">   <span class="keyword">const</span> remaining = frameDeadline - now();</span><br><span class="line">   <span class="comment">// 计算得到当前帧运行剩余时间</span></span><br><span class="line">   <span class="keyword">return</span> remaining &gt; <span class="number">0</span> ? remaining : <span class="number">0</span>;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 帧回调</span></span><br><span class="line"><span class="keyword">const</span> animationTick = <span class="function"><span class="keyword">function</span>(<span class="params">rafTime</span>) </span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> (!isIdleScheduled) &#123;</span><br><span class="line">   <span class="comment">// 不在执行空闲期回调，表明可以调用空闲期回调</span></span><br><span class="line">   isIdleScheduled = <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">// 执行Idle空闲期回调</span></span><br><span class="line">   idleTick();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 空闲期回调</span></span><br><span class="line"><span class="keyword">const</span> idleTick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 重置为false，表明可以调用空闲期回调</span></span><br><span class="line"> isIdleScheduled = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">const</span> currentTime = now();</span><br><span class="line"> <span class="keyword">if</span> (frameDeadline - currentTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 帧到期时间小于当前时间，说明已过期</span></span><br><span class="line">   <span class="keyword">if</span> (timeoutTime !== <span class="number">-1</span> &amp;&amp; timeoutTime &lt;= currentTime) &#123;</span><br><span class="line">     <span class="comment">// 此帧已过期，且发生任务处理函数（执行具体任务，传入的回调）的超时</span></span><br><span class="line">     <span class="comment">// 需要执行任务处理，下文将调用；</span></span><br><span class="line">     frameDeadlineObject.didTimeout = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 帧已过期，但没有发生任务处理函数的超时，暂时不调用任务处理函数</span></span><br><span class="line">     <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">       <span class="comment">// 当前没有调度别的帧回调函数</span></span><br><span class="line">       <span class="comment">// 调度下一帧</span></span><br><span class="line">       isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">       requestAnimationFrame(animationTick);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Exit without invoking the callback.</span></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 这一帧还有剩余时间</span></span><br><span class="line">   <span class="comment">// 标记未超时，之后调用任务处理函数</span></span><br><span class="line">   frameDeadlineObject.didTimeout = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 缓存的任务处理函数</span></span><br><span class="line"> timeoutTime = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">const</span> callback = scheduledRICCallback;</span><br><span class="line"> scheduledRICCallback = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 执行回调</span></span><br><span class="line">   callback(frameDeadlineObject);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模拟requestIdleCallback</span></span><br><span class="line">rIC = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> callback: (deadline: Deadline</span>) =&gt; <span class="title">void</span>, // 传入的任务处理函数参数</span></span><br><span class="line"><span class="function"> <span class="title">options</span>?: </span>&#123;timeout: number&#125; <span class="comment">// 其他参数</span></span><br><span class="line">) &#123;</span><br><span class="line"> <span class="comment">// 回调函数</span></span><br><span class="line"> scheduledRICCallback = callback;</span><br><span class="line"> <span class="keyword">if</span> (options != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> options.timeout === <span class="string">'number'</span>) &#123;</span><br><span class="line">   <span class="comment">// 计算过期时间</span></span><br><span class="line">   timeoutTime = now() + options.timeout;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">   <span class="comment">// 当前没有调度别的帧回调函数</span></span><br><span class="line">   isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">// 初始开始执行帧回调 </span></span><br><span class="line">   requestAnimationFrame(animationTick);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>frameDeadline：是以启发法，从30fps（即30帧）开始调整得到的更适于当前环境的一帧限制时间；</li>
<li>timeRemaining：计算requestIdleCallback此次空闲（帧）执行任务剩余时间，即距离deadline的时间；</li>
<li>options.timeout：Fiber内部调用rICAPI执行异步任务时，传递的任务到期时间参数；</li>
<li>frameDeadlineObject：计算得到的某一帧可用时间对象，两个属性分别表示：</li>
<li>didTimeout：传入的异步任务 处理函数是否超时；</li>
<li>timeRemaining：当前帧可执行任务处理函数的剩余空闲时间；</li>
<li>frameDeadlineObject对象是基于传入的timeout参数和此模块内部自调整得到的frameDeadline参数计算得出；</li>
</ul>
<h2 id="Fiber与组件"><a href="#Fiber与组件" class="headerlink" title="Fiber与组件"></a>Fiber与组件</h2><p>我们已经知道了Fiber的功能及其主要特点，那么其如何和组件联系，并且如何实现效果的呢，以下几点可以概括：</p>
<ul>
<li>React应用中的基础单元是组件，应用以组件树形式组织，渲染组件；</li>
<li>Fiber调和器基础单元则是fiber（调和单元），应用以fiber树形式组织，应用Fiber算法；</li>
<li>组件树和fiber树结构对应，一个组件实例有一个对应的fiber实例；</li>
<li>Fiber负责整个应用层面的调和，fiber实例负责对应组件的调和；</li>
</ul>
<p>注意Fiber与fiber的区别，Fiber是指调和器算法，fiber则是调和器算法组成单元，和组件与应用关系类似，每一个组件实例会有对应的fiber实例负责该组件的调和。</p>
<h2 id="Fiber数据结构"><a href="#Fiber数据结构" class="headerlink" title="Fiber数据结构"></a>Fiber数据结构</h2><p>截止目前，我们对Fiber应该有了初步的了解，在具体介绍Fiber的实现与架构之前，准备先简单介绍一下Fiber的数据结构，数据结构能一定程度反映其整体工作架构。</p>
<p>其实，一个fiber就是一个JavaScript对象，以键值对形式存储了一个关联组件的信息，包括组件接收的props，维护的state，最后需要渲染出的内容等。接下来我们将介Fiber对象的主要属性。</p>
<h2 id="Fiber对象"><a href="#Fiber对象" class="headerlink" title="Fiber对象"></a>Fiber对象</h2><p>首先<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiber.js" target="_blank" rel="noopener">Fiber</a>对象的定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个Fiber对象作用于一个组件</span></span><br><span class="line"><span class="keyword">export</span> type Fiber = &#123;|</span><br><span class="line">  <span class="comment">// 标记fiber类型tag.</span></span><br><span class="line">  tag: TypeOfWork,</span><br><span class="line">  <span class="comment">// fiber对应的function/class/module类型组件名.</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// fiber所在组件树的根组件FiberRoot对象</span></span><br><span class="line">  stateNode: any,</span><br><span class="line">  <span class="comment">// 处理完当前fiber后返回的fiber，</span></span><br><span class="line">  <span class="comment">// 返回当前fiber所在fiber树的父级fiber实例</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// fiber树结构相关链接</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  index: number,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前处理过程中的组件props对象</span></span><br><span class="line">  pendingProps: any, </span><br><span class="line">  <span class="comment">// 缓存的之前组件props对象</span></span><br><span class="line">  memoizedProps: any, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// The state used to create the output</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件状态更新及对应回调函数的存储队列</span></span><br><span class="line">  updateQueue: UpdateQueue&lt;any&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 描述当前fiber实例及其子fiber树的数位，</span></span><br><span class="line">  <span class="comment">// 如，AsyncUpdates特殊字表示默认以异步形式处理子树，</span></span><br><span class="line">  <span class="comment">// 一个fiber实例创建时，此属性继承自父级fiber，在创建时也可以修改值，</span></span><br><span class="line">  <span class="comment">// 但随后将不可修改。</span></span><br><span class="line">  internalContextTag: TypeOfInternalContext,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新任务的最晚执行时间</span></span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fiber的版本池，即记录fiber更新过程，便于恢复</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Conceptual aliases</span></span><br><span class="line">  <span class="comment">// workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens</span></span><br><span class="line">  <span class="comment">// to be the same as work in progress.</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>type &amp; key：同React元素的值；</li>
<li>type：描述fiber对应的React组件；</li>
<li>对于组合组件：值为function或class组件本身；</li>
<li>对于原生组件（div等）：值为该元素类型字符串；</li>
<li>key：调和阶段，标识fiber，以检测是否可重用该fiber实例；</li>
<li>child &amp; sibling：组件树，对应生成fiber树，类比的关系；</li>
<li>pendingProps &amp; memoizedProps：分别表示组件当前传入的及之前的props；</li>
<li>return：返回当前fiber所在fiber树的父级fiber实例，即当前组件的父组件对应的fiber；</li>
<li>alternate：fiber的版本池，即记录fiber更新过程，便于恢复重用；</li>
<li>workInProgress：正在处理的fiber，概念上叫法，实际上没有此属性；</li>
</ul>
<h3 id="ALTERNATE-FIBER"><a href="#ALTERNATE-FIBER" class="headerlink" title="ALTERNATE FIBER"></a>ALTERNATE FIBER</h3><p>可以理解为一个fiber版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中fiber的更新，因为在组件更新的各阶段，更新前及更新过程中fiber状态并不一致，在需要恢复时（如，发生冲突），即可使用另一者直接回退至上一版本fiber。</p>
<blockquote>
<p>1.使用alternate属性双向连接一个当前fiber和其work-in-progress，当前fiber实例的alternate属性指向其work-in-progress，work-in-progress的alternate属性指向当前稳定fiber；<br>2.当前fiber的替换版本是其work-in-progress，work-in-progress的交替版本是当前fiber；<br>3.当work-in-progress更新一次后，将同步至当前fiber，然后继续处理，同步直至任务完成；<br>4.work-in-progress指向处理过程中的fiber，而当前fiber总是维护处理完成的最新版本的fiber。</p>
</blockquote>
<h3 id="创建FIBER实例"><a href="#创建FIBER实例" class="headerlink" title="创建FIBER实例"></a>创建FIBER实例</h3><p>创建fiber实例即返回一个带有上一小节描述的诸多属性的JavaScript对象，FiberNode即根据传入的参数构造返回一个初始化的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createFiber = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: TypeOfWork,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  internalContextTag: TypeOfInternalContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FiberNode(tag, key, internalContextTag);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建alternate fiber以处理任务的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个alternate fiber处理任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createWorkInProgress</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> workInProgress = current.alternate;</span><br><span class="line">  <span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = createFiber(</span><br><span class="line">      current.tag,</span><br><span class="line">      current.key,</span><br><span class="line">      current.internalContextTag,</span><br><span class="line">    );</span><br><span class="line">    workInProgress.type = current.type;</span><br><span class="line">    workInProgress.stateNode = current.stateNode;</span><br><span class="line">    <span class="comment">// 形成alternate关系，互相交替模拟版本池</span></span><br><span class="line">    workInProgress.alternate = current;</span><br><span class="line">    current.alternate = workInProgress;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  workInProgress.expirationTime = expirationTime;</span><br><span class="line">  workInProgress.pendingProps = pendingProps;</span><br><span class="line">  workInProgress.child = current.child;</span><br><span class="line">  workInProgress.memoizedProps = current.memoizedProps;</span><br><span class="line">  workInProgress.memoizedState = current.memoizedState;</span><br><span class="line">  workInProgress.updateQueue = current.updateQueue;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fiber类型"><a href="#Fiber类型" class="headerlink" title="Fiber类型"></a>Fiber类型</h3><p>上一小节，Fiber对象中有个tag属性，标记fiber类型，而fiber实例是和组件对应的，所以其类型基本上对应于组件类型，源码见<a href="https://github.com/facebook/react/blob/master/packages/shared/ReactTypeOfWork.js" target="_blank" rel="noopener">ReactTypeOfWork模块</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type TypeOfWork = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span> | <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IndeterminateComponent = <span class="number">0</span>; <span class="comment">// 尚不知是类组件还是函数式组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> FunctionalComponent = <span class="number">1</span>; <span class="comment">// 函数式组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ClassComponent = <span class="number">2</span>; <span class="comment">// Class类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostRoot = <span class="number">3</span>; <span class="comment">// 组件树根组件，可以嵌套</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostPortal = <span class="number">4</span>; <span class="comment">// 子树. Could be an entry point to a different renderer.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostComponent = <span class="number">5</span>; <span class="comment">// 标准组件，如地div， span等</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostText = <span class="number">6</span>; <span class="comment">// 文本</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CallComponent = <span class="number">7</span>; <span class="comment">// 组件调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CallHandlerPhase = <span class="number">8</span>; <span class="comment">// 调用组件方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ReturnComponent = <span class="number">9</span>; <span class="comment">// placeholder（占位符）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Fragment = <span class="number">10</span>; <span class="comment">// 片段</span></span><br></pre></td></tr></table></figure>
<p>在调度执行任务的时候会根据不同类型fiber，即fiber.tag值进行不同处理。</p>
<h3 id="FiberRoot对象"><a href="#FiberRoot对象" class="headerlink" title="FiberRoot对象"></a>FiberRoot对象</h3><p>FiberRoot对象，主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息，具体定义见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberRoot.js" target="_blank" rel="noopener">ReactFiberRoot模块</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type FiberRoot = &#123;</span><br><span class="line">  <span class="comment">// fiber节点的容器元素相关信息，通常会直接传入容器元素</span></span><br><span class="line">  containerInfo: any,</span><br><span class="line">  <span class="comment">// 当前fiber树中激活状态（正在处理）的fiber节点，</span></span><br><span class="line">  current: Fiber,</span><br><span class="line">  <span class="comment">// 此节点剩余的任务到期时间</span></span><br><span class="line">  remainingExpirationTime: ExpirationTime,</span><br><span class="line">  <span class="comment">// 更新是否可以提交</span></span><br><span class="line">  isReadyForCommit: boolean,</span><br><span class="line">  <span class="comment">// 准备好提交的已处理完成的work-in-progress</span></span><br><span class="line">  finishedWork: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot</span></span><br><span class="line">  nextScheduledRoot: FiberRoot | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建FIBERROOT实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ClassComponent,</span><br><span class="line">  HostRoot</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'shared/ReactTypeOfWork'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建返回一个初始根组件对应的fiber实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHostRootFiber</span>(<span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建fiber</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiber(HostRoot, <span class="literal">null</span>, NoContext);</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建初始根组件对应的fiber实例</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = createHostRootFiber();</span><br><span class="line">  <span class="comment">// 组件树根组件的FiberRoot对象</span></span><br><span class="line">  <span class="keyword">const</span> root = &#123;</span><br><span class="line">    <span class="comment">// 根组件对应的fiber实例</span></span><br><span class="line">    current: uninitializedFiber,</span><br><span class="line">    containerInfo: containerInfo,</span><br><span class="line">    pendingChildren: <span class="literal">null</span>,</span><br><span class="line">    remainingExpirationTime: NoWork,</span><br><span class="line">    isReadyForCommit: <span class="literal">false</span>,</span><br><span class="line">    finishedWork: <span class="literal">null</span>,</span><br><span class="line">    context: <span class="literal">null</span>,</span><br><span class="line">    pendingContext: <span class="literal">null</span>,</span><br><span class="line">    hydrate,</span><br><span class="line">    nextScheduledRoot: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 组件树根组件fiber实例的stateNode指向FiberRoot对象</span></span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReactChildFiber"><a href="#ReactChildFiber" class="headerlink" title="ReactChildFiber"></a>ReactChildFiber</h3><p>在生成组件树的FiberRoot对象后，会为子组件生成各自的fiber实例，这一部分由<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactChildFiber.js" target="_blank" rel="noopener">ReactChildFiber模块实</a>现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调和（处理更新）子fibers</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 挂载（初始化）子fibers</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>而ChildReconciler方法所做的则是根据传入参数判断是调用初始化子组件fibers逻辑还是执行调和已有子组件fibers逻辑。</p>
<p>ChildReconciler方法，返回reconcileChildFibers方法：</p>
<p>1.判断子级传递内容的数据类型，执行不同的处理，这也对应着我们写React组件时传递props.children时，其类型可以是对象或数组，字符串，是数字等；<br>2.然后具体根据子组件类型，调用不同的具体调和处理函数；<br>3.最后返回根据子组件创建或更新得到的fiber实例；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildReconciler</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber, currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any, expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      <span class="comment">// 子组件实例类型，以Symbol符号表示的</span></span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">        <span class="comment">// React Element</span></span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber, currentFirstChild,</span><br><span class="line">              newChild, expirationTime</span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">        <span class="comment">// React组件调用</span></span><br><span class="line">        <span class="keyword">case</span> REACT_CALL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(reconcileSingleCall(...));</span><br><span class="line">        <span class="comment">// placeholder</span></span><br><span class="line">        <span class="keyword">case</span> REACT_RETURN_TYPE:</span><br><span class="line">          <span class="keyword">return</span> ...;</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> ...;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">'string'</span> || <span class="keyword">typeof</span> newChild === <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(reconcileSingleTextNode(...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenArray(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenIterator(...);</span><br><span class="line">    &#125;</span><br><span class="line">    ...   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h2><p>在学习Fiber的时候，我尝试去阅读源码，发现通过这种方式很难快速理解，学习Fiber，而先了解调和器是干什么的及调和器在React中的存在形式，然后再学习Fiber的结构及算法实现思路，明白从组件被定义到渲染至页面它需要做什么，这也是本篇文章的组织形式。</p>
<h3 id="优先级（ExpirationTime-VS-PriorityLevel）"><a href="#优先级（ExpirationTime-VS-PriorityLevel）" class="headerlink" title="优先级（ExpirationTime VS PriorityLevel）"></a>优先级（ExpirationTime VS PriorityLevel）</h3><p>我们已经知道Fiber可以切分任务并设置不同优先级，那么是如何实现划分优先级的呢，其表现形式什么呢？</p>
<h4 id="EXPIRATIONTIME"><a href="#EXPIRATIONTIME" class="headerlink" title="EXPIRATIONTIME"></a>EXPIRATIONTIME</h4><p>Fiber切分任务并调用requestIdleCallback和requestAnimationFrameAPI，保证渲染任务和其他任务，在不影响应用交互，不掉帧的前提下，稳定执行，而实现调度的方式正是给每一个fiber实例设置到期执行时间，不同时间即代表不同优先级，到期时间越短，则代表优先级越高，需要尽早执行。</p>
<blockquote>
<p>所谓的到期时间（ExpirationTime），是相对于调度器初始调用的起始时间而言的一个时间段；调度器初始调用后的某一段时间内，需要调度完成这项更新，这个时间段长度值就是到期时间值。</p>
</blockquote>
<p>Fiber提供<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberExpirationTime.js" target="_blank" rel="noopener">ReactFiberExpirationTime</a>模块实现到期时间的定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoWork = <span class="number">0</span>; <span class="comment">// 没有任务等待处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Sync = <span class="number">1</span>; <span class="comment">// 同步模式，立即处理任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Never = <span class="number">2147483647</span>; <span class="comment">// Max int32: Math.pow(2, 31) - 1</span></span><br><span class="line"><span class="keyword">const</span> UNIT_SIZE = <span class="number">10</span>; <span class="comment">// 过期时间单元（ms）</span></span><br><span class="line"><span class="keyword">const</span> MAGIC_NUMBER_OFFSET = <span class="number">2</span>; <span class="comment">// 到期时间偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以ExpirationTime特定单位（1单位=10ms）表示的到期执行时间</span></span><br><span class="line"><span class="comment">// 1 unit of expiration time represents 10ms.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">msToExpirationTime</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 总是增加一个偏移量，在ms&lt;10时与Nowork模式进行区别</span></span><br><span class="line">  <span class="keyword">return</span> ((ms / UNIT_SIZE) | <span class="number">0</span>) + MAGIC_NUMBER_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以毫秒表示的到期执行时间</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">expirationTimeToMs</span>(<span class="params">expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向上取整（整数单位到期执行时间）</span></span><br><span class="line"><span class="comment">// precision范围精度：弥补任务执行时间误差</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ceiling</span>(<span class="params">num, precision</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (((num / precision) | <span class="number">0</span>) + <span class="number">1</span>) * precision;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算处理误差时间在内的到期时间</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computeExpirationBucket</span>(<span class="params">currentTime, expirationInMs, bucketSizeMs,</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ceiling(</span><br><span class="line">    currentTime + expirationInMs / UNIT_SIZE,</span><br><span class="line">    bucketSizeMs / UNIT_SIZE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该模块提供的功能主要有：</p>
<p>1.Sync：同步模式，在UI线程立即执行此类任务，如动画反馈等；<br>2.异步模式：<br>  1.转换：到期时间特定单位和时间单位（ms）的相互转换；<br>  2.计算：计算包含允许误差在内的到期时间；</p>
<h4 id="PRIORITYLEVEL"><a href="#PRIORITYLEVEL" class="headerlink" title="PRIORITYLEVEL"></a>PRIORITYLEVEL</h4><p>其实在15.x版本中出现了对于任务的优先层级划分，</p>
<p><a href="https://github.com/facebook/react/blob/15.6-dev/src/renderers/shared/fiber/ReactPriorityLevel.js" target="_blank" rel="noopener">ReactPriorityLevel模块：</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type PriorityLevel = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  NoWork: <span class="number">0</span>, <span class="comment">// No work is pending.</span></span><br><span class="line">  SynchronousPriority: <span class="number">1</span>, <span class="comment">// For controlled text inputs. Synchronous side-effects.</span></span><br><span class="line">  AnimationPriority: <span class="number">2</span>, <span class="comment">// Needs to complete before the next frame.</span></span><br><span class="line">  HighPriority: <span class="number">3</span>, <span class="comment">// Interaction that needs to complete pretty soon to feel responsive.</span></span><br><span class="line">  LowPriority: <span class="number">4</span>, <span class="comment">// Data fetching, or result from updating stores.</span></span><br><span class="line">  OffscreenPriority: <span class="number">5</span>, <span class="comment">// Won't be visible but do the work in case it becomes visible.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相对于PriorityLevel的简单层级划分，在16.x版本中使用的则是ExpirationTime的到期时间方式表示任务的优先级，可以更好的对任务进行切分，调度。</p>
<h3 id="调度器（Scheduler）"><a href="#调度器（Scheduler）" class="headerlink" title="调度器（Scheduler）"></a>调度器（Scheduler）</h3><p>前面介绍调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件，而Fiber使得应用可以更好的协调不同任务的执行，调和器内关于高效协调的实现，我们可以称它为调度器（Scheduler）。</p>
<blockquote>
<p>顾名思义，调度器即调度资源以执行指定任务，React应用中应用组件的更新与渲染，需要占用系统CPU资源，如果不能很好的进行资源平衡，合理调度，优化任务执行策略，那很容易造成CPU这一紧缺资源的消耗和浪费，容易造成页面卡顿，动画掉帧，组件更新异常等诸多问题，就像城市交通调度一样，如果不能有效调度，交通状况很可能将拥堵不堪。</p>
</blockquote>
<p>在React 15.x版本中，组件的状态变更将直接导致其子组件树的重新渲染，新版本Fiber算法将在调度器方面进行全面改进，主要的关注点是：</p>
<p>1.合并多次更新：没有必要在组件的每一个状态变更时都立即触发更新任务，有些中间状态变更其实是对更新任务所耗费资源的浪费，就比如用户发现错误点击时快速操作导致组件某状态从A至B再至C，这中间的B状态变更其实对于用户而言并没有意义，那么我们可以直接合并状态变更，直接从A至C只触发一次更新；<br>2.任务优先级：不同类型的更新有不同优先级，例如用户操作引起的交互动画可能需要有更好的体验，其优先级应该比完成数据更新高；<br>3.推拉式调度：基于推送的调度方式更多的需要开发者编码间接决定如何调度任务，而拉取式调度更方便React框架层直接进行全局自主调度；</p>
<p><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js" target="_blank" rel="noopener">传送查看源码</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    computeAsyncExpiration,</span><br><span class="line">    computeExpirationForFiber,</span><br><span class="line">    scheduleWork,</span><br><span class="line">    batchedUpdates,</span><br><span class="line">    unbatchedUpdates,</span><br><span class="line">    flushSync,</span><br><span class="line">    deferredUpdates,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上调度器主要输出API为实现调度任务，拉取更新，延迟更新等功能。</p>
<h4 id="调度器与优先级"><a href="#调度器与优先级" class="headerlink" title="调度器与优先级"></a>调度器与优先级</h4><p>调度器如何切分任务划分优先级的呢？在React调和算法中，任务由fiber实例描述，所以要划分任务优先级，等效于设置fiber的到期时间（expirationTime），调度器内提供了computeExpirationForFiber方法以计算某一个fiber的到期时间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; </span><br><span class="line">  NoWork, Sync, Never, msToExpirationTime,</span><br><span class="line">  expirationTimeToMs, computeExpirationBucket</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./ReactFiberExpirationTime'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示下一个要处理的任务的到期时间，默认为NoWork，即当前没有正在等待执行的任务；</span></span><br><span class="line"><span class="comment">// Nowork默认更新策略：异步模式下，异步执行任务；同步模式下同步执行任务</span></span><br><span class="line"><span class="keyword">let</span> expirationContext = NoWork;</span><br><span class="line"><span class="comment">// 下一次渲染到期时间</span></span><br><span class="line"><span class="keyword">let</span> nextRenderExpirationTime = NoWork;</span><br><span class="line"><span class="comment">// 异步更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AsyncUpdates = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 初始时间（ms）.</span></span><br><span class="line"><span class="keyword">const</span> startTime = now();</span><br><span class="line"><span class="comment">// ExpirationTime单位表示的当前时间（ExpirationTime单位，初始值传入0）</span></span><br><span class="line"><span class="keyword">let</span> mostRecentCurrentTime = msToExpirationTime(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算fiber的到期时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeExpirationForFiber</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> expirationTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isWorking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCommitting) &#123;</span><br><span class="line">      <span class="comment">// 在提交阶段的更新任务</span></span><br><span class="line">      <span class="comment">// 需要明确设置同步优先级（Sync Priority）</span></span><br><span class="line">      expirationTime = Sync;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在渲染阶段发生的更新任务</span></span><br><span class="line">      <span class="comment">// 需要设置为下一次渲染时间的到期时间优先级</span></span><br><span class="line">      expirationTime = nextRenderExpirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不在任务执行阶段，需要计算新的过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确传递useSyncScheduling为true表明期望同步调用</span></span><br><span class="line">    <span class="comment">// 且fiber.internalContextTag != AsyncUpdates</span></span><br><span class="line">    <span class="keyword">if</span> (useSyncScheduling &amp;&amp; !(fiber.internalContextTag &amp; AsyncUpdates)) &#123;</span><br><span class="line">      <span class="comment">// 同步更新，设置为同步标记</span></span><br><span class="line">      expirationTime = Sync;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异步更新，计算异步到期时间</span></span><br><span class="line">      expirationTime = computeAsyncExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.若当前处于任务提交阶段（更新提交至DOM渲染）时，设置当前fiber到期时间为Sync，即同步执行模式；<br>2.若处于DOM渲染阶段时，则需要延迟此fiber任务，将fiber到期时间设置为下一次DOM渲染到期时间；<br>3.若不在任务执行阶段，则需重新设置fiber到期时间：<br>  1.若明确设置useSyncScheduling且fiber.internalContextTag值不等于AsyncUpdates，则表明是同步模式，设置为Sync；<br>  2.否则，调用computeAsyncExpiration方法重新计算此fiber的到期时间；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 重新计算当前时间（ExpirationTime单位表示）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recalculateCurrentTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ms = now() - startTime;</span><br><span class="line">  <span class="comment">// ExpirationTime单位表示的当前时间</span></span><br><span class="line">  <span class="comment">// 时间段值为 now() - startTime（起始时间）</span></span><br><span class="line">  mostRecentCurrentTime = msToExpirationTime(ms);</span><br><span class="line">  <span class="keyword">return</span> mostRecentCurrentTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算异步任务的到期时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeAsyncExpiration</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计算得到ExpirationTime单位的当前时间</span></span><br><span class="line">  <span class="comment">// 聚合相似的更新在一起</span></span><br><span class="line">  <span class="comment">// 更新应该在 ~1000ms，最多1200ms内完成</span></span><br><span class="line">  <span class="keyword">const</span> currentTime = recalculateCurrentTime();</span><br><span class="line">  <span class="comment">// 对于每个fiber的期望到期时间的增值，最大值为1000ms</span></span><br><span class="line">  <span class="keyword">const</span> expirationMs = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// 到期时间的可接受误差时间，200ms</span></span><br><span class="line">  <span class="keyword">const</span> bucketSizeMs = <span class="number">200</span>;</span><br><span class="line">  <span class="comment">// 返回包含误差时间在内的到期时间</span></span><br><span class="line">  <span class="keyword">return</span> computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每一个fiber我们期望的到期时间参数是1000ms，另外由于任务执行时间误差，接受200ms误差，最后计算得到的到期时间默认返回值为ExpirationTime单位。</p>
<p>####任务调度<br>上一节介绍了调度器主要提供computeExpirationForFiber等方法支持计算任务优先级（到期时间），接下来介绍调度器如何调度任务。</p>
<blockquote>
<p>React应用更新时，Fiber从当前处理节点，层层遍历至组件树根组件，然后开始处理更新，调用前面的requestIdleCallback等API执行更新处理。</p>
</blockquote>
<p>主要调度逻辑实现在scheduleWork：</p>
<p>1.通过fiber.return属性，从当前fiber实例层层遍历至组件树根组件；<br>2.依次对每一个fiber实例进行到期时间判断，若大于传入的期望任务到期时间参数，则将其更新为传入的任务到期时间；<br>3.调用requestWork方法开始处理任务，并传入获取的组件树根组件FiberRoot对象和任务到期时间；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度任务</span></span><br><span class="line"><span class="comment">// expirationTime为期望的任务到期时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleWork</span>(<span class="params">fiber, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> scheduleWorkImpl(fiber, expirationTime, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleWorkImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber, expirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> node = fiber;</span><br><span class="line">  <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 向上遍历至根组件fiber实例，并依次更新expirationTime到期时间</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      node.expirationTime === NoWork ||</span><br><span class="line">      node.expirationTime &gt; expirationTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 若fiber实例到期时间大于期望的任务到期时间，则更新fiber到期时间</span></span><br><span class="line">      node.expirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同时更新alternate fiber的到期时间</span></span><br><span class="line">    <span class="keyword">if</span> (node.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        node.alternate.expirationTime === NoWork ||</span><br><span class="line">        node.alternate.expirationTime &gt; expirationTime</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 若alternate fiber到期时间大于期望的任务到期时间，则更新fiber到期时间</span></span><br><span class="line">        node.alternate.expirationTime = expirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node.return为空，说明到达组件树顶部</span></span><br><span class="line">    <span class="keyword">if</span> (node.return === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.tag === HostRoot) &#123;</span><br><span class="line">        <span class="comment">// 确保是组件树根组件并获取FiberRoot实例</span></span><br><span class="line">        <span class="keyword">const</span> root = node.stateNode;</span><br><span class="line">        <span class="comment">// 请求处理任务</span></span><br><span class="line">        requestWork(root, expirationTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取父级组件fiber实例</span></span><br><span class="line">    node = node.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理任务的requestWork方法实现如下：</p>
<p>1.首先比较任务剩余到期时间和期望的任务到期时间，若大于，则更新值；<br>2.判断任务期望到期时间（expirationTime），区分同步或异步执行任务；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当根节点发生更新时，调度器将调用requestWork方法开始任务处理过程</span></span><br><span class="line"><span class="comment">// It's up to the renderer to call renderRoot at some point in the future.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root: FiberRoot, expirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remainingExpirationTime = root.remainingExpirationTime;</span><br><span class="line">  <span class="keyword">if</span> (remainingExpirationTime === NoWork ||</span><br><span class="line">    expirationTime &lt; remainingExpirationTime) &#123;</span><br><span class="line">    <span class="comment">// 若任务剩余到期时间大于期望的任务到期时间，则需要更新</span></span><br><span class="line">    root.remainingExpirationTime = expirationTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    performWork(Sync, <span class="literal">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    scheduleCallbackWithExpiration(expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新队列（UpdateQueue）"><a href="#更新队列（UpdateQueue）" class="headerlink" title="更新队列（UpdateQueue）"></a>更新队列（UpdateQueue）</h3><p>我们知道如果需要实现组件的异步更新，肯定需要在更新前将更新任务进行存储，然后异步任务开始的时候读取更新并实现组件更新，存储更新任务就需要一个数据结构，最常见的就是栈和队列，Fiber的实现方式就是队列。</p>
<p>Fiber切分任务为多个任务单元（Work Unit）后，需要划分优先级然后存储在更新队列，随后按优先级进行调度执行。我们知道每一个组件都对应有一个fiber实例，fiber实例即负责管理调度组件的任务单元，所以需要为每一个组件fiber实例维护一个更新队列。</p>
<p>Fiber更新队列由<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberUpdateQueue.js" target="_blank" rel="noopener">ReactFiberUpdateQueue模块</a>实现，主要涉及</p>
<p>1.创建更新队列；<br>2.添加更新至更新队列；<br>3.添加更新至fiber（即fiber实例对应的更新队列）；<br>4.处理更新队列中的更新并返回新状态对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个更新对应的数据结构</span></span><br><span class="line"><span class="keyword">export</span> type Update&lt;State&gt; = &#123;</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  partialState: PartialState&lt;any, any&gt;,</span><br><span class="line">  callback: Callback | <span class="literal">null</span>,</span><br><span class="line">  isReplace: boolean,</span><br><span class="line">  isForced: boolean,</span><br><span class="line">  next: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新队列，以单链表形式表示并持久化</span></span><br><span class="line"><span class="comment">// 调度一个更新任务时，将其添加至当前（current）fiber和work-in-progress fiber的更新队列中;</span></span><br><span class="line"><span class="comment">// 这两个更新队列相互独立但共享同一个持久化数据结构；</span></span><br><span class="line"><span class="comment">// work-in-progress更新队列通常是current fiber更新队列的子集；</span></span><br><span class="line"><span class="comment">// 发生调和时，更新任务从work-in-progress fiber更新队列移除，</span></span><br><span class="line"><span class="comment">// current fiber内的更新任务则保留，当work-in-progress中断时可以从current fiber恢复；</span></span><br><span class="line"><span class="comment">// 提交完更新时，work-in-progress fiber就会变成current fiber</span></span><br><span class="line"><span class="keyword">export</span> type UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">  <span class="comment">// 若存在更早添加至队列的更新未被处理，</span></span><br><span class="line">  <span class="comment">// 则此已处理的更新并不会从队列中移除-先进先出原则</span></span><br><span class="line">  <span class="comment">// 所以需要维护baseState，代表第一个未处理的更新的基础状态，</span></span><br><span class="line">  <span class="comment">// 通常这就是队列中的第一个更新，因为在队列首部的已处理更新会被移除</span></span><br><span class="line">  baseState: State,</span><br><span class="line">  <span class="comment">// 同理，需要维护最近的未处理的更新的到期时间，</span></span><br><span class="line">  <span class="comment">// 即未处理更新中到期时间值最小的</span></span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  first: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  last: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  callbackList: <span class="built_in">Array</span>&lt;Update&lt;State&gt;&gt; | <span class="literal">null</span>,</span><br><span class="line">  hasForceUpdate: boolean,</span><br><span class="line">  isInitialized: boolean</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加更新至更新队列</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertUpdateIntoQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 添加更新至队列尾部</span></span><br><span class="line">  <span class="keyword">if</span> (queue.last === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 队列为空</span></span><br><span class="line">    queue.first = queue.last = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue.last.next = update;</span><br><span class="line">    queue.last = update;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    queue.expirationTime === NoWork ||</span><br><span class="line">    queue.expirationTime &gt; update.expirationTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 更新最近到期时间</span></span><br><span class="line">    queue.expirationTime = update.expirationTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加更新至fiber实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertUpdateIntoFiber</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 可以创建两个独立的更新队列</span></span><br><span class="line">  <span class="comment">// alternate主要用来保存更新过程中各版本更新队列，方便崩溃或冲突时回退</span></span><br><span class="line">  <span class="keyword">const</span> alternateFiber = fiber.alternate;</span><br><span class="line">  <span class="keyword">let</span> queue1 = fiber.updateQueue;</span><br><span class="line">  <span class="keyword">if</span> (queue1 === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新队列不存在，则创建一个空的更新队列</span></span><br><span class="line">    queue1 = fiber.updateQueue = createUpdateQueue((<span class="literal">null</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> queue2;</span><br><span class="line">  <span class="keyword">if</span> (alternateFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// alternate fiber实例存在，则需要为此</span></span><br><span class="line">    queue2 = alternateFiber.updateQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue2 === <span class="literal">null</span>) &#123;</span><br><span class="line">      queue2 = alternateFiber.updateQueue = createUpdateQueue((<span class="literal">null</span>: any));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue2 = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  queue2 = queue2 !== queue1 ? queue2 : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果只存在一个更新队列</span></span><br><span class="line">  <span class="keyword">if</span> (queue2 === <span class="literal">null</span>) &#123;</span><br><span class="line">    insertUpdateIntoQueue(queue1, update);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果任意更新队列为空，则需要将更新添加至两个更新队列</span></span><br><span class="line">  <span class="keyword">if</span> (queue1.last === <span class="literal">null</span> || queue2.last === <span class="literal">null</span>) &#123;</span><br><span class="line">    insertUpdateIntoQueue(queue1, update);</span><br><span class="line">    insertUpdateIntoQueue(queue2, update);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果2个更新队列均非空，则添加更新至第一个队列，并更新另一个队列的尾部更新项</span></span><br><span class="line">  insertUpdateIntoQueue(queue1, update);</span><br><span class="line">  queue2.last = update;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理更新队列任务，返回新状态对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current, workInProgress, queue, instance, props,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; current.updateQueue === queue) &#123;</span><br><span class="line">    <span class="comment">// 克隆current fiber以创建work-in-progress fiber</span></span><br><span class="line">    <span class="keyword">const</span> currentQueue = queue;</span><br><span class="line">    queue = workInProgress.updateQueue = &#123;</span><br><span class="line">      baseState: currentQueue.baseState,</span><br><span class="line">      expirationTime: currentQueue.expirationTime,</span><br><span class="line">      first: currentQueue.first,</span><br><span class="line">      last: currentQueue.last,</span><br><span class="line">      isInitialized: currentQueue.isInitialized,</span><br><span class="line">      <span class="comment">// These fields are no longer valid because they were already committed. Reset them.</span></span><br><span class="line">      callbackList: <span class="literal">null</span>,</span><br><span class="line">      hasForceUpdate: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset the remaining expiration time. If we skip over any updates, we'll</span></span><br><span class="line">  <span class="comment">// increase this accordingly.</span></span><br><span class="line">  queue.expirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dontMutatePrevState = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> update = queue.first;</span><br><span class="line">  <span class="keyword">let</span> didSkip = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (update !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> updateExpirationTime = update.expirationTime;</span><br><span class="line">    <span class="keyword">if</span> (updateExpirationTime &gt; renderExpirationTime) &#123;</span><br><span class="line">      <span class="comment">// 此更新优先级不够，不处理，跳过</span></span><br><span class="line">      <span class="keyword">if</span> (queue.expirationTime === NoWork ||</span><br><span class="line">          queue.expirationTime &gt; updateExpirationTime</span><br><span class="line">         ) &#123;</span><br><span class="line">        <span class="comment">// 重新设置最近未处理更新的到期时间</span></span><br><span class="line">        queue.expirationTime = updateExpirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.next;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级足够，处理</span></span><br><span class="line">    <span class="keyword">let</span> partialState;</span><br><span class="line">    <span class="keyword">if</span> (update.isReplace) &#123;</span><br><span class="line">      <span class="comment">// 使用replaceState()直接替换状态对象方式更新时</span></span><br><span class="line">      <span class="comment">// 获取新状态对象</span></span><br><span class="line">      state = getStateFromUpdate(update, instance, state, props);</span><br><span class="line">      <span class="comment">// 不需要合并至之前状态对象，标记为true</span></span><br><span class="line">      dontMutatePrevState = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新部分状态方式</span></span><br><span class="line">      <span class="comment">// 获取更新部分状态时的状态对象</span></span><br><span class="line">      partialState = getStateFromUpdate(update, instance, state, props);</span><br><span class="line">      <span class="keyword">if</span> (partialState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dontMutatePrevState) &#123;</span><br><span class="line">          <span class="comment">// 上一次是替换状态，所以不能影响state</span></span><br><span class="line">          state = <span class="built_in">Object</span>.assign(&#123;&#125;, state, partialState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 更新部分状态，直接将新状态合并至上一次状态</span></span><br><span class="line">          state = <span class="built_in">Object</span>.assign(state, partialState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置标记为false</span></span><br><span class="line">        dontMutatePrevState = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 强制立即更新</span></span><br><span class="line">    <span class="keyword">if</span> (update.isForced) &#123;</span><br><span class="line">      queue.hasForceUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (update.callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Append to list of callbacks.</span></span><br><span class="line">      <span class="keyword">let</span> callbackList = queue.callbackList;</span><br><span class="line">      <span class="keyword">if</span> (callbackList === <span class="literal">null</span>) &#123;</span><br><span class="line">        callbackList = queue.callbackList = [];</span><br><span class="line">      &#125;</span><br><span class="line">      callbackList.push(update);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历下一个更新任务</span></span><br><span class="line">    update = update.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最新的状态对象</span></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新器（Updater）"><a href="#更新器（Updater）" class="headerlink" title="更新器（Updater）"></a>更新器（Updater）</h2><p>调度器协调，调度的任务主要就是执行组件或组件树更新，而这些任务则具体由更新器（Updater）完成，可以说调度器是在整个应用组件树层面掌控全局，而更新器则深入到个更具体的每一个组件内部执行。</p>
<p>每一个组件实例化时都会被注入一个更新器，负责协调组件与React核心进程的通信，其职责主要可以概括为以下几点：</p>
<p>1.找到组件实例对应的fiber实例；<br>2.询问调度器当前组件fiber实例的优先级；<br>3.将更新推入fiber的更新队列；<br>4.根据优先级调度更新任务；</p>
<p>更新器实现见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberClassComponent.js" target="_blank" rel="noopener">ReactFiberClassComponent模块：</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  scheduleWork: (fiber: Fiber, expirationTime: ExpirationTime</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">computeExpirationForFiber</span>: (<span class="params">fiber: Fiber</span>) =&gt; <span class="title">ExpirationTime</span>,</span></span><br><span class="line"><span class="function">  <span class="title">memoizeProps</span>: (<span class="params">workInProgress: Fiber, props: any</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">memoizeState</span>: (<span class="params">workInProgress: Fiber, state: any</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="comment">// Class component state updater</span></span><br><span class="line">  <span class="keyword">const</span> updater = &#123;</span><br><span class="line">    isMounted,</span><br><span class="line">    <span class="comment">// 状态变更，更新入队列</span></span><br><span class="line">    enqueueSetState(instance, partialState, callback) &#123;</span><br><span class="line">      <span class="comment">// 获取fiber</span></span><br><span class="line">      <span class="keyword">const</span> fiber = ReactInstanceMap.get(instance);</span><br><span class="line">      <span class="keyword">const</span> expirationTime = computeExpirationForFiber(fiber);</span><br><span class="line">      <span class="comment">// 创建更新任务</span></span><br><span class="line">      <span class="keyword">const</span> update = &#123;</span><br><span class="line">        expirationTime,</span><br><span class="line">        partialState,</span><br><span class="line">        callback,</span><br><span class="line">        isReplace: <span class="literal">false</span>,</span><br><span class="line">        isForced: <span class="literal">false</span>,</span><br><span class="line">        nextCallback: <span class="literal">null</span>,</span><br><span class="line">        next: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 添加更新任务至fiber</span></span><br><span class="line">      insertUpdateIntoFiber(fiber, update);</span><br><span class="line">      <span class="comment">// 调用调度器API以调度fiber任务</span></span><br><span class="line">      scheduleWork(fiber, expirationTime);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 替换状态时</span></span><br><span class="line">    enqueueReplaceState(instance, state, callback) &#123;</span><br><span class="line">      <span class="keyword">const</span> fiber = ReactInstanceMap.get(instance);</span><br><span class="line">      <span class="keyword">const</span> expirationTime = computeExpirationForFiber(fiber);</span><br><span class="line">      <span class="keyword">const</span> update = &#123;</span><br><span class="line">        expirationTime,</span><br><span class="line">        partialState: state,</span><br><span class="line">        callback,</span><br><span class="line">        isReplace: <span class="literal">true</span>,</span><br><span class="line">        isForced: <span class="literal">false</span>,</span><br><span class="line">        nextCallback: <span class="literal">null</span>,</span><br><span class="line">        next: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 添加更新任务至fiber</span></span><br><span class="line">      insertUpdateIntoFiber(fiber, update);</span><br><span class="line">      scheduleWork(fiber, expirationTime);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 强制更新</span></span><br><span class="line">    enqueueForceUpdate(instance, callback) &#123;</span><br><span class="line">      <span class="keyword">const</span> fiber = ReactInstanceMap.get(instance);</span><br><span class="line">      <span class="keyword">const</span> expirationTime = computeExpirationForFiber(fiber);</span><br><span class="line">      <span class="keyword">const</span> update = &#123;</span><br><span class="line">        expirationTime,</span><br><span class="line">        partialState: <span class="literal">null</span>,</span><br><span class="line">        callback,</span><br><span class="line">        isReplace: <span class="literal">false</span>,</span><br><span class="line">        isForced: <span class="literal">true</span>,</span><br><span class="line">        nextCallback: <span class="literal">null</span>,</span><br><span class="line">        next: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      insertUpdateIntoFiber(fiber, update);</span><br><span class="line">      scheduleWork(fiber, expirationTime);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用组件实例生命周期方法并调用更新器API</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callComponentWillReceiveProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress, instance, newProps, newContext</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldState = instance.state;</span><br><span class="line">    instance.componentWillReceiveProps(newProps, newContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instance.state !== oldState) &#123;</span><br><span class="line">      <span class="comment">// 调用更新器入队列方法</span></span><br><span class="line">      updater.enqueueReplaceState(instance, instance.state, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Class组件实例的更新器和fiber</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">adoptClassInstance</span>(<span class="params">workInProgress, instance</span>): </span>&#123;</span><br><span class="line">    <span class="comment">// 设置更新器</span></span><br><span class="line">    instance.updater = updater;</span><br><span class="line">    workInProgress.stateNode = instance;</span><br><span class="line">    <span class="comment">// 设置fiber</span></span><br><span class="line">    ReactInstanceMap.set(instance, workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化Class组件实例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">constructClassInstance</span>(<span class="params">workInProgress, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctor = workInProgress.type;</span><br><span class="line">    <span class="keyword">const</span> unmaskedContext = getUnmaskedContext(workInProgress);</span><br><span class="line">    <span class="keyword">const</span> needsContext = isContextConsumer(workInProgress);</span><br><span class="line">    <span class="keyword">const</span> context = needsContext</span><br><span class="line">    ? getMaskedContext(workInProgress, unmaskedContext)</span><br><span class="line">    : emptyObject;</span><br><span class="line">    <span class="comment">// 实例化组件类型</span></span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> ctor(props, context);</span><br><span class="line">    <span class="comment">// 设置Class实例的更新器和fiber</span></span><br><span class="line">    adoptClassInstance(workInProgress, instance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载组件实例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mountClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentWillMount === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callComponentWillMount(workInProgress, instance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 更新组件实例 </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current, workInProgress, renderExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 组件实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">    <span class="comment">// 原Props或新Props</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = workInProgress.memoizedProps;</span><br><span class="line">    <span class="keyword">let</span> newProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">if</span> (!newProps) &#123;</span><br><span class="line">      <span class="comment">// 没有新Props则直接使用原Props</span></span><br><span class="line">      newProps = oldProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentWillReceiveProps === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      (oldProps !== newProps)) &#123;</span><br><span class="line">      <span class="comment">// 调用方法进行更新器相关处理</span></span><br><span class="line">      callComponentWillReceiveProps(</span><br><span class="line">        workInProgress, instance, newProps</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据原状态对象和更新队列计算得到新状态对象</span></span><br><span class="line">    <span class="keyword">const</span> oldState = workInProgress.memoizedState;</span><br><span class="line">    <span class="keyword">let</span> newState;</span><br><span class="line">    <span class="keyword">if</span> (workInProgress.updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理更新队列更新，计算得到新State对象</span></span><br><span class="line">      newState = processUpdateQueue(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.updateQueue,</span><br><span class="line">        instance,</span><br><span class="line">        newProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newState = oldState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要更新组件</span></span><br><span class="line">    <span class="keyword">const</span> shouldUpdate = checkShouldComponentUpdate(...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentWillUpdate === <span class="string">'function'</span>) &#123;      </span><br><span class="line">        instance.componentWillUpdate(newProps, newState, newContext);      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用生命周期方法</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    adoptClassInstance,</span><br><span class="line">    constructClassInstance,</span><br><span class="line">    mountClassInstance,</span><br><span class="line">    updateClassInstance</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要实现以下几个功能：</p>
<p>1.初始化组件实例并为其设置fibre实例和更新器；</p>
<p>2.初始化或更新组件实例，根据更新队列计算得到新状态等；</p>
<p>3.调用组件实例生命周期方法，并且调用更新器API更新fiber实例等，如更新组件实例调用的callComponentWillReceiveProps方法，该方法调用组件实例的componentWillReceiveProps生命周期方法，并调用更新器updater.enqueueReplaceState方法，更新fiber实例，并将更新添加至更新队列:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用组件实例生命周期方法并调用更新器API</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callComponentWillReceiveProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">workInProgress, instance, newProps, newContext</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> oldState = instance.state;</span><br><span class="line"> instance.componentWillReceiveProps(newProps, newContext);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (instance.state !== oldState) &#123;</span><br><span class="line">   <span class="comment">// 调用更新器入队列方法</span></span><br><span class="line">   updater.enqueueReplaceState(instance, instance.state, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外需要重点关注的是insertUpdateIntoFiber方法，该方法实现将更新任务添加至组件fiber实例，内部会处理将任务添加至fiber更新队列，源码见上文更新队列中介绍的<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberUpdateQueue.js" target="_blank" rel="noopener">ReactFiberUpdateQueue模块</a>，最终还是调用insertUpdateIntoQueue。</p>
<p>获取FIBER实例<br>获取fiber实例比较简单，fiber实例通过<a href="https://github.com/facebook/react/blob/master/packages/shared/ReactInstanceMap.js" target="_blank" rel="noopener">ReactInstanceMap模块</a>提供的API进行维护</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key._reactInternalFiber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  key._reactInternalFiber = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用节点上的_reactInternalFiber属性维护fiber实例，调用get方法即可获取。</p>
<h4 id="获取优先级"><a href="#获取优先级" class="headerlink" title="获取优先级"></a>获取优先级</h4><p>fiber实例的优先级是由调度器控制，所以需要询问调度器关于当前fiber实例的优先级，调度器提供computeExpirationForFiber获取特定fiber实例的优先级，即获取特点fiber实例的到期时间（expirationTime），方法具体实现见调度器与优先级章节。</p>
<h4 id="将更新任务添加至更新队列"><a href="#将更新任务添加至更新队列" class="headerlink" title="将更新任务添加至更新队列"></a>将更新任务添加至更新队列</h4><p>组件状态变更时，将对应的组件更新任务划分优先级并根据优先级从高到低依次推入fiber实例的更新队列，诸如使用setState方法触发的更新任务通常是添加至更新队列尾部。</p>
<p>调度器完成切分任务为任务单元后，将使用performUnitOfWork方法开始处理任务单元，然后按调用组件的更新器（实现见上文介绍）相关API，按优先级将任务单元添加至fiber实例的更新队列：</p>
<p>1.从work-in-progress的alternate属性获取当前稳定fiber，然后调用beginWork开始处理更新；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理任务单元</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 当前最新版本fiber实例使用fiber的alternate属性获取</span></span><br><span class="line"> <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line"> <span class="comment">// 开始处理，返回子组件fiber实例</span></span><br><span class="line"> <span class="keyword">let</span> next = beginWork(current, workInProgress, nextRenderExpirationTime);</span><br><span class="line"> <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 不存在子级fiber，完成单元任务的处理，之后继续处理下一个任务</span></span><br><span class="line">   next = completeUnitOfWork(workInProgress);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.beginWork返回传入fiber实例的子组件fiber实例，，若为空，则代表此组件树任务处理完成，否则会在workLoop 方法内迭代调用performUnitOfWork方法处理：</p>
<p>  1.deadline：是调用requestIdleCallbackAPI执行任务处理函数时返回的帧时间对象；<br>  2.nextUnitOfWork：下一个要处理的任务单元；<br>  3.shouldYield：判断是否暂停当前任务处理过程；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">expirationTime</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 渲染更新至DOM的到期时间值 小于 调度开始至开始处理此fiber的时间段值</span></span><br><span class="line"> <span class="comment">// 说明任务已经过期</span></span><br><span class="line"> <span class="keyword">if</span> (nextRenderExpirationTime &lt;= mostRecentCurrentTime) &#123;</span><br><span class="line">   <span class="comment">// Flush all expired work， 处理所有已经到期的更新</span></span><br><span class="line">   <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Flush asynchronous work until the deadline runs out of time.</span></span><br><span class="line">   <span class="comment">// 依次处理异步更新，直至deadline到达</span></span><br><span class="line">   <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理异步任务时, 调和器将询问渲染器是否暂停执行；</span></span><br><span class="line"><span class="comment">// 在DOM中，使用requestIdleCallback API实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldYield</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (deadline === <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (deadline.timeRemaining() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">// 这一帧帧还有剩余时间，不需要暂停;</span></span><br><span class="line">   <span class="comment">// 只有非过期任务可以到达此判断条件</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> deadlineDidExpire = <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.beginWork方法内根据组件类型调用不同方法，这些方法内调用更新器API将更新添加至更新队列，具体实现见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberBeginWork.js" target="_blank" rel="noopener">ReactFiberBeginWork模快:</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入更新器模块</span></span><br><span class="line"><span class="keyword">import</span> ReactFiberClassComponent <span class="keyword">from</span> <span class="string">'./ReactFiberClassComponent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> config, hostContext, hydrationContext,</span></span></span><br><span class="line"><span class="function"><span class="params"> scheduleWork: (fiber: Fiber, expirationTime: ExpirationTime</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function"> <span class="title">computeExpirationForFiber</span>: (<span class="params">fiber: Fiber</span>) =&gt; <span class="title">ExpirationTime</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line"> <span class="comment">// 初始化更新器模块，获取API</span></span><br><span class="line"> <span class="keyword">const</span> &#123;</span><br><span class="line">   adoptClassInstance, constructClassInstance,</span><br><span class="line">   mountClassInstance, updateClassInstance</span><br><span class="line"> &#125; = ReactFiberClassComponent(</span><br><span class="line">   scheduleWork, computeExpirationForFiber,</span><br><span class="line">   memoizeProps, memoizeState</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> <span class="comment">// beginWork，开始任务处理</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">   current, workInProgress, renderExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"> </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">     <span class="comment">// 对应不同类型fiber，执行不同处理逻辑</span></span><br><span class="line">     <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">       ...</span><br><span class="line">     <span class="keyword">case</span> FunctionalComponent:</span><br><span class="line">       <span class="keyword">return</span> updateFunctionalComponent(current, workInProgress);</span><br><span class="line">     <span class="keyword">case</span> ClassComponent:</span><br><span class="line">       <span class="comment">// 更新类组件，返回子级fiber实例</span></span><br><span class="line">       <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">         current, workInProgress, renderExpirationTime</span><br><span class="line">       );</span><br><span class="line">     <span class="keyword">case</span> HostRoot:</span><br><span class="line">       <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">     <span class="keyword">case</span> HostComponent:</span><br><span class="line">       ...</span><br><span class="line">     <span class="keyword">case</span> HostText:</span><br><span class="line">       <span class="keyword">return</span> updateHostText(current, workInProgress);</span><br><span class="line">     <span class="keyword">case</span> CallHandlerPhase:</span><br><span class="line">       <span class="comment">// This is a restart. Reset the tag to the initial phase.</span></span><br><span class="line">       workInProgress.tag = CallComponent;</span><br><span class="line">     <span class="keyword">case</span> CallComponent:</span><br><span class="line">       ...</span><br><span class="line">     <span class="keyword">case</span> ReturnComponent:</span><br><span class="line">       <span class="comment">// A return component is just a placeholder, we can just run through the</span></span><br><span class="line">       <span class="comment">// next one immediately.</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">case</span> HostPortal:</span><br><span class="line">       ...</span><br><span class="line">     <span class="keyword">case</span> Fragment:</span><br><span class="line">       <span class="keyword">return</span> updateFragment(current, workInProgress);</span><br><span class="line">     <span class="keyword">default</span>:;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   beginWork,</span><br><span class="line">   beginFailedWork</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.引入ReactFiberClassComponent更新器相关模块并初始化获得API；</p>
<p>2.beginWork方法内根据传入的work-in-progress的fiber类型（tag）调用不同逻辑处理；</p>
<p>3.在逻辑处理里面会调用更新期API，将更新添加至更新队列；</p>
<p>4.以ClassComponent为例，将调用updateClassComponent方法：</p>
<p>  1.判断若第一次则初始化并挂载组件实例，否则调用updateClassInstance方法更新组件实例；</p>
<p>  2.最后调用finishClassComponent方法，调和处理其子组件并返回其子级fiber实例；</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 更新类组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">current, workInProgress, renderExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> shouldUpdate;</span><br><span class="line"><span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!workInProgress.stateNode) &#123;</span><br><span class="line">   <span class="comment">// fiber没有组件实例时需要初始化组件实例</span></span><br><span class="line">   constructClassInstance(workInProgress, workInProgress.pendingProps);</span><br><span class="line">   <span class="comment">// 挂载组件实例</span></span><br><span class="line">   mountClassInstance(workInProgress, renderExpirationTime);</span><br><span class="line">   <span class="comment">// 默认需要更新</span></span><br><span class="line">   shouldUpdate = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 处理实例更新并返回是否需要更新组件</span></span><br><span class="line"> shouldUpdate = updateClassInstance(</span><br><span class="line">   current,</span><br><span class="line">   workInProgress,</span><br><span class="line">   renderExpirationTime,</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新完成后，返回子组件fiber实例</span></span><br><span class="line"><span class="keyword">return</span> finishClassComponent(</span><br><span class="line"> current, workInProgress, shouldUpdate, hasContext</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类组件更新完成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">current, workInProgress, shouldUpdate, hasContext</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!shouldUpdate) &#123;</span><br><span class="line"> <span class="comment">// 明确设置不需要更新时，不处理更新，</span></span><br><span class="line"> <span class="comment">// 如shouldCOmponentUpdate方法return false</span></span><br><span class="line"> <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line"><span class="comment">// 重新渲染</span></span><br><span class="line">ReactCurrentOwner.current = workInProgress;</span><br><span class="line"><span class="comment">// 返回组件子组件树等内容</span></span><br><span class="line"><span class="keyword">let</span> nextChildren = instance.render();</span><br><span class="line"><span class="comment">// 调和子组件树，将迭代处理每一个组件</span></span><br><span class="line"><span class="comment">// 函数内将调用ReactChildFiber模块提供的API</span></span><br><span class="line">reconcileChildren(current, workInProgress, nextChildren);</span><br><span class="line"><span class="comment">// 返回子组件fiber实例</span></span><br><span class="line"><span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调度更新任务"><a href="#调度更新任务" class="headerlink" title="调度更新任务"></a>调度更新任务</h4><p>上一节更新器已经能按照优先级将更新添加至更新队列，那么如何调度执行更新任务呢？</p>
<p>在更新器实现<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberClassComponent.js" target="_blank" rel="noopener">ReactFiberClassComponent模块</a>中，在enqueueSetState，enqueueReplaceState和enqueueForceUpdate入队列方法中，均会调用如下方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insertUpdateIntoFiber(fiber, update);</span><br><span class="line">scheduleWork(fiber, expirationTime);</span><br></pre></td></tr></table></figure>
<p>1.insertUpdateIntoFiber：将更新添加至fiber实例，最终会添加至更新队列；<br>2.scheduleWork：调度任务，传入fiber实例和任务到期时间</p>
<h2 id="渲染与调和"><a href="#渲染与调和" class="headerlink" title="渲染与调和"></a>渲染与调和</h2><p>在调和阶段，不涉及任何DOM处理，在处理完更新后，需要渲染模块将更新渲染至DOM，这也是React应用中虚拟DOM（Virtual DOM）的概念，即所有的更新计算都基于虚拟DOM，计算完后才将优化后的更新渲染至真实DOM。Fiber使用requestIdleCallbackAPI更高效的执行渲染更新的任务，实现任务的切分。</p>
<h3 id="源码简单分析"><a href="#源码简单分析" class="headerlink" title="源码简单分析"></a>源码简单分析</h3><p>本小节针对React渲染模块及调和算法模块代码层关系做简要探讨，不感兴趣可以跳过此劫（节）。</p>
<h4 id="REACT-DOM渲染模块"><a href="#REACT-DOM渲染模块" class="headerlink" title="REACT-DOM渲染模块"></a>REACT-DOM渲染模块</h4><p>在项目中，如果要将应用渲染至页面，通常会有如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App form <span class="string">'./App'</span>; <span class="comment">// 应用根组件</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App&gt;,</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#App'</span>) <span class="comment">// 应用挂载容器DOM</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>react-dom模块就是适用于浏览器端渲染React应用的渲染方案，<a href="https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOM.js" target="_blank" rel="noopener">ReactDOM模块源码</a>结构如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactDOM = &#123;</span><br><span class="line">  render(</span><br><span class="line">    element: React$Element&lt;any&gt;, <span class="comment">// React元素，通常是项目根组件</span></span><br><span class="line">    container: DOMContainer, <span class="comment">// React应用挂载的DOM容器</span></span><br><span class="line">    callback: ?<span class="built_in">Function</span>,  <span class="comment">// 回调函数</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> renderSubtreeIntoContainer(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      callback,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>常用的渲染组件至DOM的render方法如上，调用renderSubtreeIntoContainer方法，渲染组件的子组件树：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染组件的子组件树至父容器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderSubtreeIntoContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> root = container._reactRootContainer;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 初次渲染时初始化</span></span><br><span class="line">    <span class="comment">// 创建react根容器</span></span><br><span class="line">    <span class="keyword">const</span> newRoot = DOMRenderer.createContainer(container, shouldHydrate);</span><br><span class="line">    <span class="comment">// 缓存react根容器至DOM容器的reactRootContainer属性</span></span><br><span class="line">    root = container._reactRootContainer = newRoot;</span><br><span class="line">    <span class="comment">// 初始化容器相关</span></span><br><span class="line">    <span class="comment">// Initial mount should not be batched.</span></span><br><span class="line">    DOMRenderer.unbatchedUpdates(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是初次渲染则直接更新容器</span></span><br><span class="line">    DOMRenderer.updateContainer(children, root, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回根容器fiber树的根fiber实例</span></span><br><span class="line">  <span class="keyword">return</span> DOMRenderer.getPublicRootInstance(root);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DOM渲染器对象"><a href="#DOM渲染器对象" class="headerlink" title="DOM渲染器对象"></a>DOM渲染器对象</h3><p>DOMRenderer是调用调和算法返回的DOM渲染器对象，在此处会传入渲染模块的渲染UI操作API，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用调和算法方法</span></span><br><span class="line"><span class="keyword">const</span> DOMRenderer = ReactFiberReconciler(</span><br><span class="line">  <span class="comment">// 传递至调和算法中的渲染UI（react-dom模块即DOM）</span></span><br><span class="line">  <span class="comment">// 实际操作API</span></span><br><span class="line">  &#123;</span><br><span class="line">  getPublicInstance(instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;,</span><br><span class="line">  createInstance(</span><br><span class="line">    type: string,</span><br><span class="line">    props: Props,</span><br><span class="line">    rootContainerInstance: Container,</span><br><span class="line">    hostContext: HostContext,</span><br><span class="line">    internalInstanceHandle: <span class="built_in">Object</span>,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 创建DOM元素</span></span><br><span class="line">    <span class="keyword">const</span> domElement = createElement(</span><br><span class="line">      type,</span><br><span class="line">      props,</span><br><span class="line">      rootContainerInstance,</span><br><span class="line">      parentNamespace,</span><br><span class="line">    );</span><br><span class="line">    precacheFiberNode(internalInstanceHandle, domElement);</span><br><span class="line">    updateFiberProps(domElement, props);</span><br><span class="line">    <span class="keyword">return</span> domElement;      </span><br><span class="line">  &#125;,</span><br><span class="line">  now: ReactDOMFrameScheduling.now,</span><br><span class="line">  mutation: &#123;</span><br><span class="line">    <span class="comment">// 提交渲染</span></span><br><span class="line">    commitMount(</span><br><span class="line">      domElement: Instance,</span><br><span class="line">      type: string,</span><br><span class="line">      newProps: Props,</span><br><span class="line">      internalInstanceHandle: <span class="built_in">Object</span>,</span><br><span class="line">    ) &#123;</span><br><span class="line">      ((domElement: any):</span><br><span class="line">        | HTMLButtonElement</span><br><span class="line">        | HTMLInputElement</span><br><span class="line">        | HTMLSelectElement</span><br><span class="line">        | HTMLTextAreaElement).focus();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 提交更新</span></span><br><span class="line">    commitUpdate(</span><br><span class="line">      domElement: Instance,</span><br><span class="line">      updatePayload: <span class="built_in">Array</span>&lt;mixed&gt;,</span><br><span class="line">      type: string,</span><br><span class="line">      oldProps: Props,</span><br><span class="line">      newProps: Props,</span><br><span class="line">      internalInstanceHandle: <span class="built_in">Object</span>,</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 更新属性</span></span><br><span class="line">      updateFiberProps(domElement, newProps);</span><br><span class="line">      <span class="comment">// 对DOM节点进行Diff算法分析</span></span><br><span class="line">      updateProperties(domElement, updatePayload, type, oldProps, newProps);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 清空文本内容</span></span><br><span class="line">    resetTextContent(domElement: Instance): <span class="keyword">void</span> &#123;</span><br><span class="line">      domElement.textContent = <span class="string">''</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 添加为子级</span></span><br><span class="line">    appendChild(</span><br><span class="line">      parentInstance: Instance,</span><br><span class="line">      child: Instance | TextInstance,</span><br><span class="line">    ): <span class="keyword">void</span> &#123;</span><br><span class="line">      parentInstance.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>ReactDOMFrameScheduling.now源码见Github。</p>
<p>在任务完成时将执行createInstance方法，然后调用createElement创建DOM元素并添加至文档。</p>
<p>调和算法入口<br><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberReconciler.js" target="_blank" rel="noopener">调和算法</a>入口：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactFiberScheduler <span class="keyword">from</span> <span class="string">'./ReactFiberScheduler'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;insertUpdateIntoFiber&#125; <span class="keyword">from</span> <span class="string">'./ReactFiberUpdateQueue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Reconciler</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> all parameters as config object</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 下文用到的config参数即从此处传入</span></span></span><br><span class="line"><span class="function"><span class="params">  getPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  createInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  ...</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 生成调度器API</span></span><br><span class="line">  <span class="keyword">var</span> &#123;</span><br><span class="line">    computeAsyncExpiration, computeExpirationForFiber, scheduleWork,</span><br><span class="line">    batchedUpdates, unbatchedUpdates, flushSync, deferredUpdates,</span><br><span class="line">  &#125; = ReactFiberScheduler(config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 创建容器</span></span><br><span class="line">    createContainer(containerInfo, <span class="attr">hydrate</span>: boolean) &#123;</span><br><span class="line">      <span class="comment">// 创建根fiber实例</span></span><br><span class="line">      <span class="keyword">return</span> createFiberRoot(containerInfo, hydrate);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 更新容器内容</span></span><br><span class="line">    updateContainer(</span><br><span class="line">      element: ReactNodeList,</span><br><span class="line">      container: OpaqueRoot,</span><br><span class="line">      parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">      callback: ?<span class="built_in">Function</span>,</span><br><span class="line">    ): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> current = container.current;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 更新</span></span><br><span class="line">      scheduleTopLevelUpdate(current, element, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取容器fiber树的根fiber实例</span></span><br><span class="line">    getPublicRootInstance (container) &#123;</span><br><span class="line">      <span class="comment">// 获取fiber实例</span></span><br><span class="line">      <span class="keyword">const</span> containerFiber = container.current;</span><br><span class="line">      <span class="keyword">if</span> (!containerFiber.child) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (containerFiber.child.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> HostComponent:</span><br><span class="line">          <span class="keyword">return</span> getPublicInstance(containerFiber.child.stateNode);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> containerFiber.child.stateNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    unbatchedUpdates</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在react-dom渲染模块调用createContainer创建容器和根fiber实例，FiberRoot对象，调用updateContainer方法更新容器内容。</p>
<h3 id="开始更新"><a href="#开始更新" class="headerlink" title="开始更新"></a>开始更新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleTopLevelUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">    callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">const</span> update = &#123;</span><br><span class="line">    expirationTime,</span><br><span class="line">    partialState: &#123;element&#125;,</span><br><span class="line">    callback,</span><br><span class="line">    isReplace: <span class="literal">false</span>,</span><br><span class="line">    isForced: <span class="literal">false</span>,</span><br><span class="line">    nextCallback: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 更新fiber实例</span></span><br><span class="line">  insertUpdateIntoFiber(current, update);</span><br><span class="line">  <span class="comment">// 执行任务</span></span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####处理更新<br>调用scheduleWork方法处理更新任务，实现见上文，<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js" target="_blank" rel="noopener">源码</a>。</p>
<h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>处理完更新后需要确认提交更新至渲染模块，然后渲染模块才能将更新渲染至DOM。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactFiberCommitWork <span class="keyword">from</span> <span class="string">'./ReactFiberCommitWork'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    commitResetTextContent,</span><br><span class="line">    commitPlacement,</span><br><span class="line">    commitDeletion,</span><br><span class="line">    commitWork,</span><br><span class="line">    commitLifeCycles,</span><br><span class="line">    commitAttachRef,</span><br><span class="line">    commitDetachRef,</span><br><span class="line">  &#125; = ReactFiberCommitWork(config, captureError);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">finishedWork</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  commitAllHostEffects();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环执行提交更新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> primaryEffectTag =</span><br><span class="line">        effectTag &amp; ~(Callback | Err | ContentReset | Ref | PerformedWork);</span><br><span class="line">      <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">        <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">          commitPlacement(nextEffect);</span><br><span class="line">          nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">          <span class="comment">// Placement</span></span><br><span class="line">          commitPlacement(nextEffect);</span><br><span class="line">          nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">          <span class="comment">// Update</span></span><br><span class="line">          <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">          commitWork(current, nextEffect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Update: &#123;</span><br><span class="line">          <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">          commitWork(current, nextEffect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">          isUnmounting = <span class="literal">true</span>;</span><br><span class="line">          commitDeletion(nextEffect);</span><br><span class="line">          isUnmounting = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Flush sync work.</span></span><br><span class="line"><span class="keyword">let</span> finishedWork = root.finishedWork;</span><br><span class="line"><span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// This root is already complete. We can commit it.</span></span><br><span class="line">  root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  root.remainingExpirationTime = commitRoot(finishedWork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberCommitWork.js" target="_blank" rel="noopener">提交更新</a>是最后确认更新组件的阶段，主要逻辑如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">mutation, ...</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    commitMount,</span><br><span class="line">    commitUpdate,</span><br><span class="line">    resetTextContent,</span><br><span class="line">    commitTextUpdate,</span><br><span class="line">    appendChild,</span><br><span class="line">    appendChildToContainer,</span><br><span class="line">    insertBefore,</span><br><span class="line">    insertInContainerBefore,</span><br><span class="line">    removeChild,</span><br><span class="line">    removeChildFromContainer,</span><br><span class="line">  &#125; = mutation; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">current: Fiber | null, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">        <span class="keyword">const</span> instance: I = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Commit the work prepared earlier.</span></span><br><span class="line">          <span class="keyword">const</span> newProps = finishedWork.memoizedProps;</span><br><span class="line">          <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">          <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">          <span class="comment">// this case.</span></span><br><span class="line">          <span class="keyword">const</span> oldProps = current !== <span class="literal">null</span> ? current.memoizedProps : newProps;</span><br><span class="line">          <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Type the updateQueue to be specific to host components.</span></span><br><span class="line">          <span class="keyword">const</span> updatePayload = finishedWork.updateQueue:;</span><br><span class="line">          finishedWork.updateQueue = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (updatePayload !== <span class="literal">null</span>) &#123;</span><br><span class="line">            commitUpdate(</span><br><span class="line">              instance,</span><br><span class="line">              updatePayload,</span><br><span class="line">              type,</span><br><span class="line">              oldProps,</span><br><span class="line">              newProps,</span><br><span class="line">              finishedWork,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HostText: &#123;   </span><br><span class="line">        <span class="keyword">const</span> textInstance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">const</span> newText = finishedWork.memoizedProps;</span><br><span class="line">        <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">        <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">        <span class="comment">// this case.</span></span><br><span class="line">        <span class="keyword">const</span> oldText: string =</span><br><span class="line">          current !== <span class="literal">null</span> ? current.memoizedProps : newText;</span><br><span class="line">        commitTextUpdate(textInstance, oldText, newText);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">快乐至上</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/08/06/9531/" class="pre-post btn btn-default" title='理解ReactElement和ReactClass的概念'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">理解ReactElement和ReactClass的概念</span>
        </a>
    
    
        <a href="/2018/08/02/9529/" class="next-post btn btn-default" title='rollup 介绍'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">rollup 介绍</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#全新的内部架构"><span class="toc-text">全新的内部架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染"><span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调和（Reconciliation）"><span class="toc-text">调和（Reconciliation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-Reconciler"><span class="toc-text">Stack Reconciler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber-Reconciler"><span class="toc-text">Fiber Reconciler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber与JavaScript"><span class="toc-text">Fiber与JavaScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空闲期（Idle-Period）"><span class="toc-text">空闲期（Idle Period）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber与requestIdleCallback"><span class="toc-text">Fiber与requestIdleCallback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber与组件"><span class="toc-text">Fiber与组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber数据结构"><span class="toc-text">Fiber数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber对象"><span class="toc-text">Fiber对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ALTERNATE-FIBER"><span class="toc-text">ALTERNATE FIBER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建FIBER实例"><span class="toc-text">创建FIBER实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fiber类型"><span class="toc-text">Fiber类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FiberRoot对象"><span class="toc-text">FiberRoot对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReactChildFiber"><span class="toc-text">ReactChildFiber</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber架构"><span class="toc-text">Fiber架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优先级（ExpirationTime-VS-PriorityLevel）"><span class="toc-text">优先级（ExpirationTime VS PriorityLevel）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXPIRATIONTIME"><span class="toc-text">EXPIRATIONTIME</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PRIORITYLEVEL"><span class="toc-text">PRIORITYLEVEL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度器（Scheduler）"><span class="toc-text">调度器（Scheduler）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调度器与优先级"><span class="toc-text">调度器与优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新队列（UpdateQueue）"><span class="toc-text">更新队列（UpdateQueue）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新器（Updater）"><span class="toc-text">更新器（Updater）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取优先级"><span class="toc-text">获取优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将更新任务添加至更新队列"><span class="toc-text">将更新任务添加至更新队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度更新任务"><span class="toc-text">调度更新任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染与调和"><span class="toc-text">渲染与调和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码简单分析"><span class="toc-text">源码简单分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#REACT-DOM渲染模块"><span class="toc-text">REACT-DOM渲染模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM渲染器对象"><span class="toc-text">DOM渲染器对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开始更新"><span class="toc-text">开始更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#提交更新"><span class="toc-text">提交更新</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>❤</span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>